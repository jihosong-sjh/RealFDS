# Implementation Plan: 알림 확인 및 처리 시스템 (Alert Management System)

**Branch**: `002-alert-management` | **Date**: 2025-11-10 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-alert-management/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command based on the feature specification.

## Summary

알림 확인 및 처리 시스템은 001-realtime-fds MVP의 기존 Alert 모델을 확장하여 보안 담당자가 알림의 전체 라이프사이클을 관리할 수 있도록 합니다. 알림 상태 추적(미확인/확인중/완료), 담당자 할당, 조치 내용 기록 기능을 제공하며, 탐지 규칙별 심각도(LOW/MEDIUM/HIGH/CRITICAL)를 자동으로 할당하여 색상으로 구분 표시합니다.

기술적으로는 기존 인메모리 저장소(alert-service)에 상태 관리 필드를 추가하고, WebSocket을 통해 상태 변경을 실시간 브로드캐스트하며, React 프론트엔드에 상태 변경 UI, 필터링, 상세 모달을 추가합니다. 시스템 재시작 시 알림 상태는 초기화되며(최근 100개 제한), 데이터베이스 영속성은 003-alert-history에서 구현 예정입니다.

## Technical Context

**언어/버전**:
- Java 17+ (alert-service, websocket-gateway 확장)
- Java 11+ with Scala 2.12 (fraud-detector 확장 - 규칙에 severity 추가)
- TypeScript 5.0+ with React 18+ (frontend-dashboard 확장)

**주요 의존성**:
- Spring Boot 3.2+ with Spring WebFlux (기존 사용 중)
- Spring Kafka (기존 사용 중)
- React 18+ with Vite 5.0+ (기존 사용 중)
- WebSocket API (기존 사용 중)

**스토리지**:
- 인메모리 저장소 (alert-service: 최근 100개 알림만 유지, 상태 포함)
- 상태 필드: status, assignedTo, actionNote, processedAt 추가

**테스팅**:
- Java/Spring: JUnit 5 + Mockito (기존 테스트 확장)
- React: Vitest + React Testing Library (기존 테스트 확장)
- E2E: Docker Compose + Bash 스크립트

**타겟 플랫폼**:
- 로컬 개발 환경 (Docker Compose)
- Windows, macOS, Linux 지원
- 최소 요구사항: 8GB RAM, 4 core CPU (기존과 동일)

**프로젝트 타입**: 마이크로서비스 확장 (기존 5개 서비스 수정)

**성능 목표**:
- 알림 상태 변경 반영: 평균 0.5초, 최대 1초
- 상태 변경 동기화: 모든 클라이언트에 1초 이내
- 필터링 응답 시간: <100ms (100개 알림 기준)
- 모달 로딩 시간: <200ms

**제약사항**:
- 총 메모리: <4GB 유지 (추가 컨테이너 없음)
- 인메모리 저장소: 최근 100개 알림만 상태 관리
- 시스템 재시작 시 상태 초기화 (영속성 없음)

**규모/범위**:
- 기존 5개 서비스 수정 (신규 서비스 없음)
- Alert 모델 확장: 4개 필드 추가
- DetectionRule 확장: severity 필드 추가
- 3개 UI 컴포넌트 추가/수정

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**목적**: 모든 구현 결정이 프로젝트 Constitution의 핵심 원칙을 준수하는지 검증합니다.

### I. 학습 우선 접근 (Learning-First Approach)

- [x] 기능이 실시간 스트리밍 개념을 명확하게 보여줍니까? → 상태 변경의 실시간 브로드캐스트로 WebSocket 활용 강화
- [x] 구현이 명시적 패턴을 사용합니까 (암시적 마법 금지)? → 상태 관리 로직이 명시적으로 분리됨
- [x] 포괄적인 로깅이 계획되어 있습니까? → 상태 변경 이벤트 로깅 추가
- [x] "무엇을"과 "왜"가 모두 문서화됩니까? → spec.md에 명확히 문서화
- [x] ❌ 인증/인가 시스템을 추가하지 않습니까? → 담당자는 이름만 저장 (인증 없음)
- [x] ❌ 복잡한 보안 기능을 구현하지 않습니까? → 단순한 상태 관리만 구현

**결과**: ✅ 통과 - 모든 항목 준수

---

### II. 완벽함보다 단순함 (Simplicity Over Perfection)

- [x] 단일 명령어 배포 (`docker-compose up`)가 가능합니까? → 기존 docker-compose.yml 수정 없음
- [x] 외부 의존성이 최소화되어 있습니까? → 새로운 외부 의존성 없음
- [x] 합리적인 기본값을 가진 환경 변수를 사용합니까? → 기존 환경 변수 구조 유지
- [x] Windows, macOS, Linux에서 모두 작동합니까? → 기존 Docker 기반 유지
- [x] ❌ 수동 설정 파일 편집을 요구하지 않습니까? → 추가 설정 불필요
- [x] ❌ 클라우드 전용 서비스를 사용하지 않습니까? → 로컬 실행만 지원

**결과**: ✅ 통과 - 모든 항목 준수

---

### III. 실시간 우선 (Real-time First)

- [x] 서비스 간 이벤트 기반 통신을 사용합니까? → Kafka 이벤트 구조 유지
- [x] 상태 기반(stateful) 스트림 처리가 필요한 경우 적절히 구현됩니까? → 이 기능은 stateless (상태 저장만)
- [x] 브라우저 통신에 WebSocket을 사용합니까 (폴링 금지)? → 기존 WebSocket 활용, 상태 변경 브로드캐스트 추가
- [N/A] 시간 기반 집계에 적절한 윈도우(windowing)를 사용합니까? → 이 기능에 해당 없음
- [N/A] 이벤트 시간(event-time) 시맨틱을 사용합니까? → 이 기능에 해당 없음
- [x] ❌ REST API 폴링을 사용하지 않습니까? → WebSocket만 사용
- [x] ❌ 배치(batch) 처리를 사용하지 않습니까? → 실시간 처리만 사용

**성능 목표 충족**:
- [x] 평균 종단 간 지연 시간 <5초 (목표: <3초) → 상태 변경은 <1초로 더 빠름
- [x] p95 종단 간 지연 시간 <8초 (목표: <5초) → 상태 변경 성능 영향 최소

**결과**: ✅ 통과 - 모든 항목 준수

---

### IV. 마이크로서비스 경계 (Microservice Boundaries)

**주의**: 이 기능은 기존 MVP의 5개 서비스 구조를 유지합니다 (Constitution의 3개 서비스 권장과 상이하나, 001-realtime-fds에서 정당화됨).

- [x] 각 서비스가 단일 책임을 가집니까? → 각 서비스 책임 변경 없음, 기능만 확장
- [x] 각 서비스가 독립적으로 배포 가능합니까? → 기존 독립성 유지
- [x] 서비스 간 통신이 Kafka만 사용합니까? → Kafka + WebSocket (브라우저) 구조 유지
- [x] 각 서비스가 헬스 체크 엔드포인트를 노출합니까? → 기존 /actuator/health 유지
- [x] ❌ 추가 서비스를 생성하지 않습니까? → 신규 서비스 없음
- [x] ❌ 서비스 간 HTTP/REST 직접 호출을 사용하지 않습니까? → Kafka + WebSocket만 사용
- [x] ❌ 공유 데이터베이스를 사용하지 않습니까? → 인메모리 저장소만 사용

**메모리 제한 준수**:
- [x] transaction-generator: <256MB (수정 없음)
- [x] fraud-detector: <2GB (severity 필드만 추가, 메모리 영향 최소)
- [x] alert-service: <512MB (4개 필드 추가, 메모리 영향 최소)
- [x] websocket-gateway: <512MB (상태 브로드캐스트 추가, 메모리 영향 최소)
- [x] frontend-dashboard: <256MB (UI 컴포넌트 추가, 메모리 영향 최소)

**결과**: ✅ 통과 - 기존 5개 서비스 구조 유지 (001에서 정당화됨)

---

### V. 테스트 및 품질 표준 (Test & Quality Standards)

- [x] 단위 테스트 커버리지 ≥70% 계획되어 있습니까? → 새로운 로직에 대한 단위 테스트 추가
- [x] 통합 테스트가 계획되어 있습니까? → 상태 변경 E2E 시나리오 테스트
- [x] 성능 테스트 계획되어 있습니까? → 상태 변경 지연 시간 측정
- [x] Given-When-Then 구조 사용이 계획되어 있습니까? → spec.md에 명시된 acceptance scenarios 활용
- [x] 서술적인 변수/함수 이름을 사용합니까? → 코드 리뷰 시 확인
- [x] 최대 함수 길이 50줄, 파일 길이 300줄을 준수합니까? → 코드 리뷰 시 확인
- [x] Conventional Commits 형식 (한국어)을 사용합니까? → 커밋 시 준수
- [x] 구조화된 로깅 (SLF4J + JSON)이 계획되어 있습니까? → 기존 로깅 구조 유지

**오류 처리**:
- [x] 예외를 조용히 무시하지 않습니까? → 모든 예외 로깅
- [x] 컨텍스트와 함께 오류를 로깅합니까? → alertId, userId 포함
- [x] Kafka 연결에 서킷 브레이커를 구현합니까? → 기존 구현 유지

**결과**: ✅ 통과 - 모든 항목 준수

---

### VI. 한국어 우선 (Korean-First Documentation)

- [x] 모든 코드 주석을 한국어로 작성합니까? → 한국어 주석 사용
- [x] 커밋 메시지를 Conventional Commits + 한국어로 작성합니까? → 한국어 커밋 메시지
- [x] 모든 공식 문서를 한국어로 작성합니까? → spec.md, plan.md 모두 한국어
- [x] 변수/함수명은 영어 사용, 필요시 한국어 주석을 추가합니까? → 표준 준수
- [x] ❌ 한 문장/주석 내에서 한국어와 영어를 혼용하지 않습니까? → 언어 일관성 유지

**결과**: ✅ 통과 - 모든 항목 준수

---

### 기술 스택 준수

**필수 기술**:
- [x] Apache Kafka 3.6+ → 기존 사용 중
- [x] Apache Flink 1.18+ → fraud-detector에서 사용 중 (severity 추가만)
- [x] Spring Boot 3.2+ → alert-service, websocket-gateway에서 사용 중
- [x] React 18+ + TypeScript 5+ → frontend-dashboard에서 사용 중
- [x] Docker + Docker Compose → 기존 사용 중

**금지 기술** (사용 시 반드시 정당화 필요):
- [x] ❌ Kubernetes 사용하지 않음
- [x] ❌ 서비스 메시 사용하지 않음
- [x] ❌ 클라우드 전용 서비스 사용하지 않음
- [x] ❌ NoSQL 데이터베이스 사용하지 않음 (인메모리만 사용)
- [x] ❌ API 게이트웨이 사용하지 않음

**결과**: ✅ 통과 - 모든 항목 준수

---

### Constitution Check 결과

**통과**: [x] 모든 항목이 준수됨

**요약**:
- 6개 핵심 원칙 모두 준수
- 기존 MVP 아키텍처를 확장하는 방식으로 복잡성 최소화
- 새로운 외부 의존성 없음
- 메모리 제한 준수
- 실시간 특성 강화 (상태 변경 실시간 동기화)

## Project Structure

### Documentation (this feature)

```text
specs/002-alert-management/
├── spec.md              # Feature specification (입력)
├── plan.md              # This file (실행 계획)
├── research.md          # Phase 0: 기술 연구 (이 feature는 생략 가능 - 기존 기술 재사용)
├── data-model.md        # Phase 1: 데이터 모델 정의
├── quickstart.md        # Phase 1: 빠른 시작 가이드 (기존 quickstart.md 업데이트)
├── contracts/           # Phase 1: API 계약서
│   ├── rest-api.md      # 새로운 REST API 엔드포인트
│   └── websocket-api.md # WebSocket 이벤트 스키마 업데이트
└── checklists/
    └── requirements.md  # 검증 완료
```

### Source Code (repository root)

**Structure Decision**: 기존 마이크로서비스 아키텍처 유지 - 5개 서비스 확장

```text
RealFDS/
├── docker-compose.yml           # 수정 없음
├── README.md                    # 업데이트 (새 기능 설명)
│
├── fraud-detector/              # 서비스 1: 탐지 엔진 (확장)
│   ├── src/main/scala/com/realfds/detector/
│   │   ├── models/
│   │   │   └── Alert.scala      # severity 필드 추가
│   │   └── rules/
│   │       ├── HighValueRule.scala       # severity = HIGH 설정
│   │       ├── ForeignCountryRule.scala  # severity = MEDIUM 설정
│   │       └── HighFrequencyRule.scala   # severity = HIGH 설정
│   └── src/test/scala/          # 테스트 업데이트
│
├── alert-service/               # 서비스 2: 알림 저장 및 관리 (확장)
│   └── src/main/java/com/realfds/alert/
│       ├── model/
│       │   └── Alert.java       # status, assignedTo, actionNote, processedAt 필드 추가
│       ├── repository/
│       │   └── AlertRepository.java  # 상태 업데이트 메서드 추가
│       ├── service/
│       │   └── AlertService.java     # 상태 관리 비즈니스 로직 추가
│       └── controller/
│           └── AlertController.java  # PATCH 엔드포인트 추가
│
├── websocket-gateway/           # 서비스 3: WebSocket 게이트웨이 (확장)
│   └── src/main/java/com/realfds/gateway/
│       ├── handler/
│       │   └── AlertWebSocketHandler.java  # 상태 변경 브로드캐스트 추가
│       └── service/
│           └── BroadcastService.java       # 상태 변경 이벤트 처리 추가
│
└── frontend-dashboard/          # 서비스 4: React 프론트엔드 (확장)
    └── src/
        ├── types/
        │   └── alert.ts         # Alert 타입에 새 필드 추가
        ├── components/
        │   ├── AlertItem.tsx                # 상태 뱃지, 담당자, 심각도 색상 추가
        │   ├── AlertDetailModal.tsx         # 신규: 상세 모달
        │   ├── AlertFilterPanel.tsx         # 신규: 필터 패널
        │   └── SeverityBadge.tsx            # 신규: 심각도 뱃지
        └── hooks/
            └── useAlertManagement.ts        # 신규: 상태 관리 hook
```

**주요 변경 사항**:
- fraud-detector: 3개 규칙에 severity 설정 추가 (코드 수정 최소)
- alert-service: Alert 모델 확장, 상태 관리 API 추가
- websocket-gateway: 상태 변경 브로드캐스트 추가
- frontend-dashboard: UI 컴포넌트 3개 추가, 1개 수정
- transaction-generator: 수정 없음

## Complexity Tracking

이 기능은 Constitution의 모든 원칙을 준수하므로 위반 사항이 없습니다.

**참고**: 5개 서비스 구조는 001-realtime-fds에서 이미 정당화되었습니다.

---

## Phase 0: Research (생략 가능)

**결정**: 이 feature는 기존 MVP의 기술 스택을 그대로 사용하므로 별도의 research.md 생성을 생략합니다.

**근거**:
- 모든 기술은 001-realtime-fds에서 이미 선택되고 검증됨
- Spring Boot, Spring WebFlux, React, WebSocket 모두 사용 중
- 새로운 외부 라이브러리나 패턴 도입 없음
- 데이터 모델 확장과 UI 추가만 필요

**생략하는 섹션**:
- 스트림 처리 엔진 선택 (이미 Flink 사용 중)
- 메시지 브로커 선택 (이미 Kafka 사용 중)
- WebSocket 라이브러리 선택 (이미 Spring WebSocket 사용 중)
- 프론트엔드 프레임워크 선택 (이미 React + Vite 사용 중)

---

## Phase 1: Design & Contracts

**Prerequisites**: 이 feature는 research.md를 생략하므로 즉시 Phase 1 시작 가능

### 1.1 Data Model Design

**목표**: 기존 Alert 모델을 확장하고 DetectionRule에 severity 추가

**출력 파일**: `data-model.md`

**주요 내용**:
1. **Alert 엔터티 확장**:
   - 기존 필드 유지: alertId, originalTransaction, ruleName, reason, alertTimestamp
   - 신규 필드 추가:
     - `status`: enum ('UNREAD' | 'IN_PROGRESS' | 'COMPLETED')
     - `assignedTo`: string | null (담당자 이름, 최대 100자)
     - `actionNote`: string | null (조치 내용, 최대 2000자)
     - `processedAt`: timestamp | null (완료 처리 시각)

2. **DetectionRule 엔터티 확장**:
   - 신규 필드 추가:
     - `severity`: enum ('LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL')
   - 규칙별 severity 매핑:
     - HIGH_VALUE: HIGH
     - FOREIGN_COUNTRY: MEDIUM
     - HIGH_FREQUENCY: HIGH

3. **상태 전이 다이어그램**:
   - UNREAD → IN_PROGRESS → COMPLETED
   - 역방향 전이 가능 (예: COMPLETED → IN_PROGRESS)

4. **유효성 검증 규칙**:
   - status: 3가지 값 중 하나 필수
   - assignedTo: 최대 100자
   - actionNote: 최대 2000자
   - processedAt: status가 COMPLETED일 때 자동 설정

### 1.2 API Contracts

**목표**: 새로운 REST API 엔드포인트 및 WebSocket 이벤트 정의

**출력 파일**: `contracts/rest-api.md`, `contracts/websocket-api.md` (업데이트)

#### REST API (contracts/rest-api.md)

```
PATCH /api/alerts/{alertId}/status
Request:
  {
    "status": "IN_PROGRESS" | "COMPLETED"
  }
Response:
  {
    "alertId": "uuid",
    "status": "IN_PROGRESS",
    "processedAt": "2025-11-10T10:30:00Z" (COMPLETED인 경우만)
  }

PATCH /api/alerts/{alertId}/assign
Request:
  {
    "assignedTo": "김보안"
  }
Response:
  {
    "alertId": "uuid",
    "assignedTo": "김보안"
  }

POST /api/alerts/{alertId}/action
Request:
  {
    "actionNote": "고객 확인 완료",
    "status": "COMPLETED" (optional)
  }
Response:
  {
    "alertId": "uuid",
    "actionNote": "고객 확인 완료",
    "status": "COMPLETED",
    "processedAt": "2025-11-10T10:30:00Z"
  }

GET /api/alerts?status={}&assignedTo={}&severity={}
Request: Query parameters (all optional)
  - status: UNREAD | IN_PROGRESS | COMPLETED
  - assignedTo: string
  - severity: LOW | MEDIUM | HIGH | CRITICAL
Response:
  {
    "alerts": [Alert array]
  }
```

#### WebSocket Events (contracts/websocket-api.md 업데이트)

```
// 기존 이벤트 (유지)
{
  "type": "NEW_ALERT",
  "alert": { ... }
}

// 신규 이벤트 (추가)
{
  "type": "ALERT_STATUS_CHANGED",
  "alertId": "uuid",
  "status": "IN_PROGRESS",
  "assignedTo": "김보안" (optional),
  "actionNote": "..." (optional),
  "processedAt": "2025-11-10T10:30:00Z" (optional)
}
```

### 1.3 Quickstart Guide

**목표**: 기존 quickstart.md 업데이트 - 새 기능 사용법 추가

**출력 파일**: `quickstart.md` (업데이트)

**추가 내용**:
1. **알림 상태 관리**:
   - 알림 클릭 → 상세 모달 → 상태 변경 → 실시간 반영
2. **담당자 할당**:
   - 상세 모달에서 담당자 이름 입력 → 저장
3. **조치 내용 기록**:
   - 상세 모달에서 조치 내용 입력 → 완료 버튼 → 처리 시각 자동 기록
4. **필터링**:
   - 상태별, 담당자별, 심각도별 필터 사용법
5. **심각도 색상**:
   - CRITICAL: 빨간색, HIGH: 주황색, MEDIUM: 노란색, LOW: 파란색

### 1.4 Agent Context Update

**실행**: `.specify/scripts/bash/update-agent-context.sh claude`

**업데이트 내용**:
- CLAUDE.md에 새 기능 추가
- 활성 기술 스택 유지 (변경 없음)

---

## Dependencies & Execution Order

### Feature 의존성

**Prerequisite Features**:
- **001-realtime-fds**: MVP 완료 (Alert 모델, WebSocket 인프라 필요)

**Dependent Features**:
- **003-alert-history**: 이 feature의 Alert 모델 확장을 사용하여 DB 스키마 설계
- **005-alert-analytics**: 알림 상태 데이터를 활용한 통계 분석

### Phase 간 의존성

- Phase 0 (Research): 생략
- Phase 1 (Design & Contracts): 즉시 시작 가능
- Phase 2 (Tasks): `/speckit.tasks` 명령으로 별도 생성

### 구현 순서 권장

1. **Backend 먼저** (순차 실행):
   - fraud-detector: 규칙에 severity 추가
   - alert-service: Alert 모델 확장, 상태 관리 API
   - websocket-gateway: 상태 변경 브로드캐스트

2. **Frontend 나중** (backend 완료 후):
   - Alert 타입 업데이트
   - UI 컴포넌트 추가/수정
   - 상태 관리 hook

3. **통합 테스트** (마지막):
   - E2E 시나리오 테스트
   - 성능 테스트

---

## Notes

- 이 feature는 기존 MVP를 확장하므로 복잡도가 낮음
- 새로운 외부 의존성 없음
- 메모리 영향 최소 (필드 4개 추가)
- Phase 0 (research.md) 생략 가능
- Phase 1 산출물: data-model.md, contracts/ (2개), quickstart.md 업데이트
- Phase 2 산출물: tasks.md (별도 명령으로 생성)

---

**계획 상태**: ✅ 완료
**다음 단계**: `/speckit.tasks` 명령으로 구현 작업 분해
