# Implementation Plan: 실시간 금융 거래 탐지 시스템 (Real-time Financial Detection System)

**Branch**: `001-realtime-fds` | **Date**: 2025-11-06 | **Spec**: [specs/001-realtime-fds/spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-realtime-fds/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command based on the feature specification and user requirements.

## Summary

실시간 금융 거래 탐지 시스템(RealFDS)은 Apache Kafka를 메시지 브로커로, Apache Flink를 스트림 처리 엔진으로 사용하여 금융 거래를 실시간으로 모니터링하고 의심스러운 패턴(고액 거래, 해외 거래, 빈번한 거래)을 즉시 탐지하는 마이크로서비스 아키텍처 기반 시스템입니다. 5개의 독립적인 서비스(transaction-generator, fraud-detector, alert-service, websocket-gateway, frontend-dashboard)로 구성되며, WebSocket을 통해 브라우저에 실시간 알림을 전달합니다. Docker Compose를 사용하여 단일 명령어로 전체 시스템을 실행하고, 거래 발생부터 알림 표시까지 5초 이내의 종단 간 지연 시간을 목표로 합니다.

## Technical Context

**언어/버전**:
- Python 3.11+ (transaction-generator)
- Java 11+ with Scala 2.12 (fraud-detector using Apache Flink)
- Java 17+ (alert-service, websocket-gateway using Spring WebFlux)
- TypeScript 5.0+ with React 18+ (frontend-dashboard)

**주요 의존성**:
- Apache Kafka 3.6+ (메시지 브로커)
- Apache Flink 1.18+ (스트림 처리 엔진, Java/Scala)
- Spring Boot 3.2+ with Spring WebFlux (reactive 백엔드)
- Spring Kafka (Kafka 통합)
- React 18+ with Vite 5.0+ (프론트엔드)
- WebSocket API (실시간 통신)

**스토리지**:
- 인메모리 저장소 (alert-service: 최근 100개 알림만 유지)
- Flink RocksDB State Backend (빈번한 거래 탐지를 위한 상태 관리)
- Kafka 토픽 보관: transactions (1시간), alerts (24시간)

**테스팅**:
- Python: pytest + pytest-kafka
- Java/Spring: JUnit 5 + Mockito + TestContainers (Kafka)
- Flink: Flink Testing Harness
- React: Vitest + React Testing Library
- E2E: Docker Compose + Bash 스크립트

**타겟 플랫폼**:
- 로컬 개발 환경 (Docker Compose)
- Windows, macOS, Linux 지원
- 최소 요구사항: 8GB RAM, 4 core CPU

**프로젝트 타입**: 마이크로서비스 (5개 독립 서비스)

**성능 목표**:
- 종단 간 지연 시간: 평균 3초, p95 5초 (목표), 최대 8초 (허용)
- 처리량: 초당 10개 거래 (목표), 초당 100개 (최대)
- 알림 표시 지연: 1초 이내 (탐지 후 브라우저 표시)
- 시스템 시작 시간: 5분 이내

**제약사항**:
- 총 메모리: <4GB (모든 컨테이너 합계)
- 개별 서비스 메모리: transaction-generator <256MB, fraud-detector <2GB, alert-service <512MB, websocket-gateway <512MB
- 로컬 실행 전용 (클라우드 서비스 사용 불가)
- 단일 명령어 배포 필수 (docker-compose up)

**규모/범위**:
- 5개 마이크로서비스
- 3가지 탐지 규칙 (고액, 해외, 빈번한 거래)
- 10명 가상 사용자 풀
- 최근 100개 알림 유지
- 30분 이상 안정적 실행

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**목적**: 모든 구현 결정이 프로젝트 Constitution의 핵심 원칙을 준수하는지 검증합니다.

### I. 학습 우선 접근 (Learning-First Approach)

- [x] 기능이 실시간 스트리밍 개념을 명확하게 보여줍니까? → Kafka + Flink 스트림 처리로 명시적으로 보여줌
- [x] 구현이 명시적 패턴을 사용합니까 (암시적 마법 금지)? → 각 서비스의 역할이 명확히 분리됨
- [x] 포괄적인 로깅이 계획되어 있습니까? → 모든 서비스에서 구조화된 로깅 사용
- [x] "무엇을"과 "왜"가 모두 문서화됩니까? → spec.md, plan.md, research.md로 계층적 문서화
- [x] ❌ 인증/인가 시스템을 추가하지 않습니까? → 학습용 프로젝트이므로 제외
- [x] ❌ 복잡한 보안 기능을 구현하지 않습니까? → 보안 기능 제외 (Out of Scope)

**결과**: ✅ 통과 - 모든 항목 준수

---

### II. 완벽함보다 단순함 (Simplicity Over Perfection)

- [x] 단일 명령어 배포 (`docker-compose up`)가 가능합니까? → Docker Compose로 전체 시스템 실행
- [x] 외부 의존성이 최소화되어 있습니까? → Kafka, Flink만 사용, 클라우드 서비스 불사용
- [x] 합리적인 기본값을 가진 환경 변수를 사용합니까? → 모든 환경 변수에 기본값 제공
- [x] Windows, macOS, Linux에서 모두 작동합니까? → Docker 기반으로 크로스 플랫폼 지원
- [x] ❌ 수동 설정 파일 편집을 요구하지 않습니까? → 모든 설정을 환경 변수로 외부화
- [x] ❌ 클라우드 전용 서비스를 사용하지 않습니까? → 로컬 실행 전용

**결과**: ✅ 통과 - 모든 항목 준수

---

### III. 실시간 우선 (Real-time First)

- [x] 서비스 간 이벤트 기반 통신을 사용합니까? → Kafka로 모든 서비스 간 통신
- [x] 상태 기반(stateful) 스트림 처리가 필요한 경우 적절히 구현됩니까? → Flink RocksDB State Backend 사용
- [x] 브라우저 통신에 WebSocket을 사용합니까 (폴링 금지)? → WebSocket으로 실시간 알림 푸시
- [x] 시간 기반 집계에 적절한 윈도우(windowing)를 사용합니까? → 1분 텀블링 윈도우 사용
- [x] 이벤트 시간(event-time) 시맨틱을 사용합니까? → Flink event-time 처리 사용
- [x] ❌ REST API 폴링을 사용하지 않습니까? → WebSocket만 사용
- [x] ❌ 배치(batch) 처리를 사용하지 않습니까? → 완전한 스트림 처리

**성능 목표 충족**:
- [x] 평균 종단 간 지연 시간 <5초 (목표: <3초) → 아키텍처상 달성 가능
- [x] p95 종단 간 지연 시간 <8초 (목표: <5초) → 성능 테스트로 검증 예정

**결과**: ✅ 통과 - 모든 항목 준수

---

### IV. 마이크로서비스 경계 (Microservice Boundaries)

**⚠️ 주의**: Constitution은 3개 서비스(TGS, RDE, RAD)를 규정하나, 사용자 요구사항은 5개 서비스를 명시

**사용자 요구사항 (5개 서비스)**:
1. transaction-generator (Python) - TGS에 해당
2. fraud-detector (Flink) - RDE에 해당
3. alert-service (Spring WebFlux) - 알림 저장
4. websocket-gateway (Spring WebFlux) - WebSocket 푸시
5. frontend-dashboard (React) - 브라우저 UI

**Constitution 매핑 (3개 서비스)**:
1. TGS = transaction-generator
2. RDE = fraud-detector
3. RAD = alert-service + websocket-gateway + frontend-dashboard (통합)

**결정**: 사용자 명시 요구사항(5개 서비스)을 따르되, Complexity Tracking에서 정당화

- [⚠️] 정확히 3개의 서비스만 사용합니까? → **위반**: 5개 서비스 사용 (정당화 필요)
- [x] 각 서비스가 단일 책임을 가집니까? → 각 서비스가 명확한 역할 분리
- [x] 각 서비스가 독립적으로 배포 가능합니까? → Docker 컨테이너로 독립 배포
- [x] 서비스 간 통신이 Kafka만 사용합니까? → Kafka + WebSocket (클라이언트 통신)
- [x] 각 서비스가 헬스 체크 엔드포인트를 노출합니까? → Spring Actuator 사용
- [⚠️] ❌ 추가 서비스를 생성하지 않습니까? → **위반**: 2개 추가 서비스
- [x] ❌ 서비스 간 HTTP/REST 직접 호출을 사용하지 않습니까? → Kafka만 사용
- [x] ❌ 공유 데이터베이스를 사용하지 않습니까? → 각 서비스가 독립적 저장소

**메모리 제한 준수** (5개 서비스 기준):
- [x] transaction-generator: <256MB
- [x] fraud-detector: <2GB
- [x] alert-service: <512MB
- [x] websocket-gateway: <512MB
- [x] frontend-dashboard: <256MB (정적 파일 서빙)

**결과**: ⚠️ 조건부 통과 - 서비스 개수 위반 (Complexity Tracking에서 정당화)

---

### V. 테스트 및 품질 표준 (Test & Quality Standards)

- [x] 단위 테스트 커버리지 ≥70% 계획되어 있습니까? → 각 탐지 규칙 단위 테스트
- [x] 3가지 탐지 규칙 모두에 대한 통합 테스트가 계획되어 있습니까? → E2E 테스트 계획
- [x] 성능 테스트 (5초 미만 지연) 계획되어 있습니까? → 지연 시간 측정 스크립트
- [x] Given-When-Then 구조 사용이 계획되어 있습니까? → spec.md의 Acceptance Scenarios 사용
- [x] 서술적인 변수/함수 이름을 사용합니까? → 코딩 표준 준수
- [x] 최대 함수 길이 50줄, 파일 길이 300줄을 준수합니까? → 코드 리뷰에서 검증
- [x] Conventional Commits 형식 (한국어)을 사용합니까? → Git 워크플로우에 명시
- [x] 구조화된 로깅 (SLF4J + JSON)이 계획되어 있습니까? → Logback + JSON 레이아웃

**오류 처리**:
- [x] 예외를 조용히 무시하지 않습니까? → 모든 예외 로깅 및 처리
- [x] 컨텍스트와 함께 오류를 로깅합니까? → transactionId, userId 포함
- [x] Kafka 연결에 서킷 브레이커를 구현합니까? → Spring Retry + Circuit Breaker

**결과**: ✅ 통과 - 모든 항목 준수

---

### VI. 한국어 우선 (Korean-First Documentation)

- [x] 모든 코드 주석을 한국어로 작성합니까? → 한국어 주석 사용
- [x] 커밋 메시지를 Conventional Commits + 한국어로 작성합니까? → 한국어 커밋 메시지
- [x] 모든 공식 문서를 한국어로 작성합니까? → spec.md, plan.md 모두 한국어
- [x] 변수/함수명은 영어 사용, 필요시 한국어 주석을 추가합니까? → 표준 준수
- [x] ❌ 한 문장/주석 내에서 한국어와 영어를 혼용하지 않습니까? → 언어 일관성 유지

**결과**: ✅ 통과 - 모든 항목 준수

---

### 기술 스택 준수

**필수 기술**:
- [x] Apache Kafka 3.6+
- [x] Apache Flink 1.18+ (사용자 명시 요구사항)
- [x] Spring Boot 3.2+ (alert-service, websocket-gateway)
- [x] React 18+ + TypeScript 5+ (frontend-dashboard)
- [x] Docker + Docker Compose

**금지 기술** (사용 시 반드시 정당화 필요):
- [x] ❌ Kubernetes 사용하지 않음
- [x] ❌ 서비스 메시 사용하지 않음
- [x] ❌ 클라우드 전용 서비스 사용하지 않음
- [x] ❌ NoSQL 데이터베이스 사용하지 않음 (인메모리만 사용)
- [x] ❌ API 게이트웨이 사용하지 않음

**결과**: ✅ 통과 - 모든 항목 준수

---

### Constitution Check 결과

**조건부 통과**: [x] 일부 위반 있으나 정당화됨 (Complexity Tracking 참조)

**위반 항목**:
- 마이크로서비스 개수: Constitution 3개 vs 사용자 요구사항 5개
- 정당화: Complexity Tracking 섹션 참조

**통과 항목**: 5/6 원칙 완전 준수, 1/6 원칙 조건부 준수

## Project Structure

### Documentation (this feature)

```text
specs/001-realtime-fds/
├── spec.md              # Feature specification (입력)
├── plan.md              # This file (실행 계획)
├── research.md          # Phase 0: 기술 선택 및 패턴 연구
├── data-model.md        # Phase 1: 데이터 모델 정의
├── quickstart.md        # Phase 1: 빠른 시작 가이드
├── contracts/           # Phase 1: API 계약서
│   ├── kafka-events.md  # Kafka 이벤트 스키마
│   ├── websocket-api.md # WebSocket API 명세
│   └── health-check.md  # 헬스 체크 엔드포인트
└── tasks.md             # Phase 2: 작업 분해 (/speckit.tasks 명령으로 생성)
```

### Source Code (repository root)

**Structure Decision**: 마이크로서비스 아키텍처 - 5개 독립 서비스로 구성

```text
RealFDS/
├── docker-compose.yml           # 전체 시스템 오케스트레이션
├── .env.example                 # 환경 변수 템플릿
├── README.md                    # 프로젝트 개요 및 빠른 시작
├── .gitignore
│
├── transaction-generator/       # 서비스 1: 거래 데이터 생성기 (Python)
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── src/
│   │   ├── main.py             # 진입점
│   │   ├── generator.py        # 거래 생성 로직
│   │   ├── kafka_producer.py   # Kafka 발행
│   │   └── models.py           # Transaction 모델
│   ├── tests/
│   │   ├── test_generator.py
│   │   └── test_kafka_producer.py
│   └── README.md
│
├── fraud-detector/              # 서비스 2: 실시간 탐지 엔진 (Flink)
│   ├── Dockerfile
│   ├── build.gradle            # Gradle 빌드 (Scala + Java)
│   ├── src/
│   │   └── main/
│   │       ├── scala/
│   │       │   └── com/realfds/detector/
│   │       │       ├── FraudDetectionJob.scala       # Flink Job 진입점
│   │       │       ├── rules/
│   │       │       │   ├── HighValueRule.scala       # 고액 거래 규칙
│   │       │       │   ├── ForeignCountryRule.scala  # 해외 거래 규칙
│   │       │       │   └── HighFrequencyRule.scala   # 빈번한 거래 규칙
│   │       │       └── models/
│   │       │           ├── Transaction.scala
│   │       │           └── Alert.scala
│   │       └── resources/
│   │           ├── logback.xml
│   │           └── application.conf
│   ├── src/test/
│   │   └── scala/
│   │       └── com/realfds/detector/
│   │           └── rules/
│   │               ├── HighValueRuleTest.scala
│   │               ├── ForeignCountryRuleTest.scala
│   │               └── HighFrequencyRuleTest.scala
│   └── README.md
│
├── alert-service/               # 서비스 3: 알림 저장 및 관리 (Spring WebFlux)
│   ├── Dockerfile
│   ├── build.gradle            # Gradle 빌드 (Java 17)
│   ├── src/
│   │   └── main/
│   │       ├── java/
│   │       │   └── com/realfds/alert/
│   │       │       ├── AlertServiceApplication.java
│   │       │       ├── config/
│   │       │       │   ├── KafkaConfig.java
│   │       │       │   └── WebFluxConfig.java
│   │       │       ├── consumer/
│   │       │       │   └── AlertConsumer.java      # Kafka alert 토픽 구독
│   │       │       ├── repository/
│   │       │       │   └── AlertRepository.java    # 인메모리 저장소 (최근 100개)
│   │       │       ├── service/
│   │       │       │   └── AlertService.java       # 알림 비즈니스 로직
│   │       │       ├── controller/
│   │       │       │   ├── HealthController.java   # /actuator/health
│   │       │       │   └── AlertController.java    # REST API (조회용)
│   │       │       └── model/
│   │       │           └── Alert.java
│   │       └── resources/
│   │           ├── application.yml
│   │           └── logback-spring.xml
│   ├── src/test/
│   │   └── java/
│   │       └── com/realfds/alert/
│   │           ├── consumer/AlertConsumerTest.java
│   │           ├── repository/AlertRepositoryTest.java
│   │           └── service/AlertServiceTest.java
│   └── README.md
│
├── websocket-gateway/           # 서비스 4: WebSocket 게이트웨이 (Spring WebFlux)
│   ├── Dockerfile
│   ├── build.gradle            # Gradle 빌드 (Java 17)
│   ├── src/
│   │   └── main/
│   │       ├── java/
│   │       │   └── com/realfds/gateway/
│   │       │       ├── WebSocketGatewayApplication.java
│   │       │       ├── config/
│   │       │       │   ├── WebSocketConfig.java
│   │       │       │   └── RestClientConfig.java
│   │       │       ├── handler/
│   │       │       │   └── AlertWebSocketHandler.java  # WebSocket 연결 관리
│   │       │       ├── service/
│   │       │       │   ├── AlertStreamService.java     # alert-service 연동
│   │       │       │   └── BroadcastService.java       # 클라이언트 브로드캐스트
│   │       │       └── controller/
│   │       │           └── HealthController.java
│   │       └── resources/
│   │           ├── application.yml
│   │           └── logback-spring.xml
│   ├── src/test/
│   │   └── java/
│   │       └── com/realfds/gateway/
│   │           ├── handler/AlertWebSocketHandlerTest.java
│   │           └── service/BroadcastServiceTest.java
│   └── README.md
│
├── frontend-dashboard/          # 서비스 5: React 프론트엔드 대시보드
│   ├── Dockerfile
│   ├── package.json
│   ├── vite.config.ts
│   ├── tsconfig.json
│   ├── src/
│   │   ├── main.tsx            # 진입점
│   │   ├── App.tsx             # 루트 컴포넌트
│   │   ├── components/
│   │   │   ├── AlertList.tsx           # 알림 목록 표시
│   │   │   ├── AlertItem.tsx           # 개별 알림
│   │   │   ├── ConnectionStatus.tsx    # 연결 상태 표시
│   │   │   └── Header.tsx
│   │   ├── hooks/
│   │   │   └── useWebSocket.ts         # WebSocket 연결 관리
│   │   ├── services/
│   │   │   └── websocketService.ts     # WebSocket 클라이언트
│   │   ├── types/
│   │   │   └── alert.ts                # Alert 타입 정의
│   │   └── utils/
│   │       └── formatter.ts            # 시간, 금액 포맷
│   ├── public/
│   │   └── favicon.ico
│   ├── tests/
│   │   ├── components/
│   │   │   ├── AlertList.test.tsx
│   │   │   └── AlertItem.test.tsx
│   │   └── hooks/
│   │       └── useWebSocket.test.ts
│   └── README.md
│
├── scripts/                     # 유틸리티 스크립트
│   ├── setup.sh                # 초기 환경 설정
│   ├── test-e2e.sh             # E2E 테스트 실행
│   └── measure-latency.sh      # 지연 시간 측정
│
└── docs/                        # 추가 문서
    ├── architecture.md         # 아키텍처 설명
    ├── development.md          # 개발 가이드
    └── troubleshooting.md      # 문제 해결 가이드
```

**주요 구조 특징**:
1. **서비스 독립성**: 각 서비스가 자체 Dockerfile, 빌드 설정, 테스트를 가짐
2. **언어 다양성**: Python (generator), Scala+Java (Flink), Java (Spring), TypeScript (React)
3. **테스트 구조**: 각 서비스별로 단위/통합 테스트 분리
4. **문서화**: 각 서비스별 README + 전체 docs/ 디렉토리
5. **실행 편의성**: 루트의 docker-compose.yml로 전체 시스템 통합 실행

## Complexity Tracking

> Constitution Check에서 식별된 위반 사항에 대한 정당화

| 위반 사항 | 필요한 이유 | 더 단순한 대안을 거부한 이유 |
|-----------|------------|------------------------------|
| **5개 서비스 사용** (Constitution: 3개) | 사용자가 명시적으로 5개 마이크로서비스 아키텍처를 요구함:<br>1. transaction-generator<br>2. fraud-detector<br>3. alert-service<br>4. websocket-gateway<br>5. frontend-dashboard | **3개 서비스 통합 대안 (Constitution 준수)**: <br>- RAD = alert-service + websocket-gateway + frontend-dashboard 통합<br><br>**거부 이유**:<br>1. **학습 목표**: 사용자가 명시적으로 "5개 마이크로서비스 아키텍처 구현 능력 증명"을 목표로 설정<br>2. **관심사 분리**: alert-service(데이터 저장), websocket-gateway(실시간 통신), frontend-dashboard(UI)는 각각 독립적 책임<br>3. **기술 다양성**: Spring WebFlux(백엔드) vs React+Vite(프론트엔드) 분리로 각 기술 스택 학습<br>4. **포트폴리오 가치**: 더 많은 서비스 = 더 복잡한 마이크로서비스 오케스트레이션 시연<br>5. **확장성 데모**: alert-service와 websocket-gateway 분리로 수평 확장 패턴 시연 가능<br><br>**결론**: Constitution의 "학습 우선" 원칙과 사용자의 명시적 요구사항을 존중하여 5개 서비스 사용 |
