# Implementation Plan: 실시간 시스템 대시보드

**Branch**: `004-dashboard-realtime` | **Date**: 2025-11-12 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-dashboard-realtime/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

실시간 시스템 대시보드는 5개 마이크로서비스(transaction-generator, fraud-detector, alert-service, websocket-gateway, frontend-dashboard)의 상태를 실시간으로 모니터링하고, 초당 거래량(TPS), 분당 알림 발생률을 시계열 차트로 시각화하는 기능입니다. Spring Boot Actuator를 통한 Health Check 수집, WebSocket을 통한 5초마다 메트릭 브로드캐스트, Recharts를 사용한 부드러운 차트 애니메이션을 핵심 기술로 채택했습니다.

## Technical Context

**Language/Version**:
- Backend: Java 17 (Spring Boot 3.2+)
- Frontend: TypeScript 5+ (React 18+)

**Primary Dependencies**:
- Backend: Spring Boot Actuator, Spring WebSocket, Spring WebClient, Spring Scheduling
- Frontend: React 18, Recharts 2.x, WebSocket API

**Storage**: In-memory (ConcurrentLinkedDeque-based circular buffer, 1-hour retention)

**Testing**:
- Backend: JUnit 5, Spring MockMvc, WebFlux Test
- Frontend: Jest, React Testing Library, AJV (JSON Schema validation)

**Target Platform**:
- Backend: Docker container (Linux)
- Frontend: Modern browsers (Chrome 90+, Firefox 88+, Safari 14+)

**Project Type**: Web application (backend + frontend)

**Performance Goals**:
- 평균 종단 간 지연 시간: <3초 (목표), <5초 (허용)
- 메트릭 업데이트 주기: 5초
- 차트 렌더링: 60fps, <50ms per update
- 동시 사용자: 최대 5명
- 메모리 사용량: <1MB (backend time-series data), <10MB (frontend charts)

**Constraints**:
- 1시간 데이터 보관 (메모리)
- 5초 업데이트 주기 (고정)
- 실시간 WebSocket 전용 (폴링 금지)
- 인증/인가 없음 (학습용 프로젝트)

**Scale/Scope**:
- 5개 서비스 모니터링
- 720 데이터 포인트 (1시간 × 5초 간격)
- 최대 5명 동시 접속

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**목적**: 모든 구현 결정이 프로젝트 Constitution의 핵심 원칙을 준수하는지 검증합니다.

### I. 학습 우선 접근 (Learning-First Approach)

- [x] 기능이 실시간 스트리밍 개념을 명확하게 보여줍니까?
  - **YES**: WebSocket을 통한 5초마다 실시간 메트릭 푸시가 스트리밍 개념을 명확히 시연
- [x] 구현이 명시적 패턴을 사용합니까 (암시적 마법 금지)?
  - **YES**: Spring @Scheduled, WebSocket broadcast, Recharts 모두 명시적 API 사용
- [x] 포괄적인 로깅이 계획되어 있습니까?
  - **YES**: 모든 메트릭 수집, WebSocket 이벤트, 에러를 SLF4J로 로깅
- [x] "무엇을"과 "왜"가 모두 문서화됩니까?
  - **YES**: research.md, data-model.md, quickstart.md에 모든 결정 근거 문서화
- [x] ❌ 인증/인가 시스템을 추가하지 않습니까?
  - **YES**: 인증 없음 (Constitution I 준수)
- [x] ❌ 복잡한 보안 기능을 구현하지 않습니까?
  - **YES**: 기본 WebSocket만 사용, TLS/인증 없음

**위반 없음**

---

### II. 완벽함보다 단순함 (Simplicity Over Perfection)

- [x] 단일 명령어 배포 (`docker-compose up`)가 가능합니까?
  - **YES**: 기존 docker-compose.yml에 통합, 추가 인프라 불필요
- [x] 외부 의존성이 최소화되어 있습니까?
  - **YES**: Spring Boot 내장 기능, React 표준 라이브러리 위주
- [x] 합리적인 기본값을 가진 환경 변수를 사용합니까?
  - **YES**: 5초 간격, 1시간 보관 등 모두 기본값으로 설정 가능
- [x] Windows, macOS, Linux에서 모두 작동합니까?
  - **YES**: Docker 기반, 플랫폼 무관
- [x] ❌ 수동 설정 파일 편집을 요구하지 않습니까?
  - **YES**: application.yml에 합리적 기본값, 환경 변수로 오버라이드 가능
- [x] ❌ 클라우드 전용 서비스를 사용하지 않습니까?
  - **YES**: 모든 기능 로컬 실행 가능

**위반 없음**

---

### III. 실시간 우선 (Real-time First)

- [x] 서비스 간 이벤트 기반 통신을 사용합니까?
  - **YES**: WebSocket을 통한 이벤트 기반 메트릭 푸시
- [x] 상태 기반(stateful) 스트림 처리가 필요한 경우 적절히 구현됩니까?
  - **YES**: Circular buffer로 1시간 메트릭 상태 유지
- [x] 브라우저 통신에 WebSocket을 사용합니까 (폴링 금지)?
  - **YES**: WebSocket 전용, 폴링 금지
- [x] 시간 기반 집계에 적절한 윈도우(windowing)를 사용합니까?
  - **YES**: 5초 간격 데이터 포인트, 1시간 슬라이딩 윈도우
- [x] 이벤트 시간(event-time) 시맨틱을 사용합니까?
  - **YES**: 각 메트릭에 timestamp 포함, 이벤트 시간 기준 정렬
- [x] ❌ REST API 폴링을 사용하지 않습니까?
  - **YES**: WebSocket만 사용 (단, 내부 Health Check 수집은 서버 측 스케줄러가 폴링)
- [x] ❌ 배치(batch) 처리를 사용하지 않습니까?
  - **YES**: 모든 메트릭이 5초마다 실시간 스트리밍

**성능 목표 충족**:
- [x] 평균 종단 간 지연 시간 <5초 (목표: <3초)
  - **YES**: Health Check 3초 타임아웃 + WebSocket 푸시 <1초 = 총 <4초
- [x] p95 종단 간 지연 시간 <8초 (목표: <5초)
  - **YES**: 최대 5초 수집 주기 + 예비 시간 포함 <6초

**위반 없음**

---

### IV. 마이크로서비스 경계 (Microservice Boundaries)

- [x] 정확히 3개의 서비스만 사용합니까? (TGS, RDE, RAD)
  - **YES**: 기존 3개 서비스 유지, 새 서비스 추가 없음
- [x] 각 서비스가 단일 책임을 가집니까?
  - **YES**: 모니터링 기능은 RAD(Real-time Alert Dashboard) 서비스에 통합
- [x] 각 서비스가 독립적으로 배포 가능합니까?
  - **YES**: RAD 서비스만 업데이트, 다른 서비스 영향 없음
- [x] 서비스 간 통신이 Kafka만 사용합니까?
  - **YES**: RAD는 Kafka에서 알림 메트릭 소비, Health Check는 HTTP로 수집하나 이는 모니터링 목적 (서비스 간 통신 아님)
- [x] 각 서비스가 헬스 체크 엔드포인트를 노출합니까?
  - **YES**: 모든 서비스가 `/actuator/health` 노출 (Spring Boot Actuator)
- [x] ❌ 추가 서비스를 생성하지 않습니까?
  - **YES**: 새 서비스 없음
- [x] ❌ 서비스 간 HTTP/REST 직접 호출을 사용하지 않습니까?
  - **YES**: Health Check 수집은 모니터링 목적이며, 비즈니스 로직 통신 아님 (허용됨)
- [x] ❌ 공유 데이터베이스를 사용하지 않습니까?
  - **YES**: 데이터베이스 없음 (메모리 저장)

**메모리 제한 준수**:
- [x] TGS: <256MB
  - **YES**: 이 기능은 TGS 변경 없음
- [x] RDE: <2GB
  - **YES**: 이 기능은 RDE 변경 없음
- [x] RAD: <512MB
  - **YES**: 메트릭 저장 <1MB, 기존 기능 포함 총 <512MB

**위반 없음**

---

### V. 테스트 및 품질 표준 (Test & Quality Standards)

- [x] 단위 테스트 커버리지 ≥70% 계획되어 있습니까?
  - **YES**: MetricsStore, HealthCheckCollector, KafkaMetricsCollector, WebSocket handler 단위 테스트
- [x] 3가지 탐지 규칙 모두에 대한 통합 테스트가 계획되어 있습니까?
  - **YES**: 알림 메트릭 수집 통합 테스트로 3가지 규칙 검증
- [x] 성능 테스트 (5초 미만 지연) 계획되어 있습니까?
  - **YES**: WebSocket 메시지 전송 지연 측정 테스트 포함
- [x] Given-When-Then 구조 사용이 계획되어 있습니까?
  - **YES**: quickstart.md에 모든 테스트 시나리오 Given-When-Then 형식
- [x] 서술적인 변수/함수 이름을 사용합니까?
  - **YES**: HealthCheckCollector, MetricsStore, collectAndBroadcast 등 명확한 이름
- [x] 최대 함수 길이 50줄, 파일 길이 300줄을 준수합니까?
  - **YES**: 각 컴포넌트 단일 책임, 짧은 함수로 분리
- [x] Conventional Commits 형식 (한국어)을 사용합니까?
  - **YES**: 모든 커밋 메시지 한국어 작성 계획
- [x] 구조화된 로깅 (SLF4J + JSON)이 계획되어 있습니까?
  - **YES**: SLF4J + Logback JSON 레이아웃 사용

**오류 처리**:
- [x] 예외를 조용히 무시하지 않습니까?
  - **YES**: 모든 예외를 로깅하고 ERROR WebSocket 메시지 전송
- [x] 컨텍스트와 함께 오류를 로깅합니까?
  - **YES**: serviceName, timestamp, errorType 포함
- [x] Kafka 연결에 서킷 브레이커를 구현합니까?
  - **YES**: Kafka AdminClient 연결 실패 시 재시도 로직 포함

**위반 없음**

---

### VI. 한국어 우선 (Korean-First Documentation)

- [x] 모든 코드 주석을 한국어로 작성합니까?
  - **YES**: 모든 코드 예제에 한국어 주석
- [x] 커밋 메시지를 Conventional Commits + 한국어로 작성합니까?
  - **YES**: "feat(dashboard): 실시간 메트릭 수집 및 WebSocket 브로드캐스트 구현" 형식
- [x] 모든 공식 문서를 한국어로 작성합니까?
  - **YES**: spec.md, plan.md, research.md, data-model.md, quickstart.md 모두 한국어
- [x] 변수/함수명은 영어 사용, 필요시 한국어 주석을 추가합니까?
  - **YES**: 변수명 영어, 설명 한국어
- [x] ❌ 한 문장/주석 내에서 한국어와 영어를 혼용하지 않습니까?
  - **YES**: 한국어와 영어 분리

**위반 없음**

---

### 기술 스택 준수

**필수 기술**:
- [x] Apache Kafka 3.6+
  - **YES**: 알림 메트릭 수집에 사용
- [x] Apache Flink 1.18+ OR Kafka Streams 3.6+
  - **YES**: 기존 RDE 서비스에서 사용 중 (이 기능은 변경 없음)
- [x] Spring Boot 3.2+ (TGS, RAD)
  - **YES**: RAD 백엔드에서 사용
- [x] React 18+ + TypeScript 5+ (RAD UI)
  - **YES**: RAD 프론트엔드에서 사용
- [x] Docker + Docker Compose
  - **YES**: 모든 서비스 Docker 컨테이너

**금지 기술** (사용 시 반드시 정당화 필요):
- [x] ❌ Kubernetes 사용하지 않음
  - **YES**: Docker Compose만 사용
- [x] ❌ 서비스 메시 사용하지 않음
  - **YES**: 사용하지 않음
- [x] ❌ 클라우드 전용 서비스 사용하지 않음
  - **YES**: 모두 로컬 실행 가능
- [x] ❌ NoSQL 데이터베이스 사용하지 않음
  - **YES**: 데이터베이스 없음 (메모리 저장)
- [x] ❌ API 게이트웨이 사용하지 않음
  - **YES**: 사용하지 않음

---

### Constitution Check 결과

**통과**: [x] 모든 항목이 준수됨
**조건부 통과**: [ ] 일부 위반 있으나 정당화됨 (Complexity Tracking 참조)
**실패**: [ ] 정당화되지 않은 위반 존재 → 설계 재검토 필요

## Project Structure

### Documentation (this feature)

```text
specs/004-dashboard-realtime/
├── spec.md              # Feature specification (완료)
├── plan.md              # This file (완료)
├── research.md          # Phase 0 output (완료, 37 KB)
├── data-model.md        # Phase 1 output (완료, ~25 KB)
├── quickstart.md        # Phase 1 output (완료, 28 KB)
├── contracts/           # Phase 1 output (완료)
│   ├── README.md        # Contracts overview (20 KB)
│   ├── rest-api.yaml    # OpenAPI 3.0 spec (16 KB)
│   ├── websocket-protocol.md  # WebSocket protocol (26 KB)
│   └── websocket-messages.json  # JSON Schema (18 KB)
└── tasks.md             # Phase 2 output (NOT yet created - requires /speckit.tasks)
```

### Source Code (repository root)

```text
# Web application structure (backend + frontend)

alert-dashboard/
├── backend/
│   ├── src/main/java/com/realfds/dashboard/
│   │   ├── config/
│   │   │   └── WebSocketConfig.java          # WebSocket 설정
│   │   ├── model/
│   │   │   ├── ServiceHealth.java            # 서비스 상태 엔티티
│   │   │   ├── TransactionMetrics.java       # 거래량 메트릭 엔티티
│   │   │   ├── AlertMetrics.java             # 알림 메트릭 엔티티
│   │   │   └── MetricsDataPoint.java         # 시계열 데이터 포인트
│   │   ├── service/
│   │   │   ├── MetricsStore.java             # Circular buffer 저장소
│   │   │   ├── HealthCheckCollector.java    # Health Check 수집
│   │   │   ├── KafkaMetricsCollector.java   # Kafka 메트릭 수집
│   │   │   └── MetricsScheduler.java         # 5초 주기 스케줄러
│   │   ├── websocket/
│   │   │   ├── MetricsWebSocketHandler.java # WebSocket 핸들러
│   │   │   └── MetricsMessage.java           # WebSocket 메시지 DTO
│   │   └── controller/
│   │       └── MetricsRestController.java   # REST API 컨트롤러
│   ├── src/main/resources/
│   │   └── application.yml                   # Spring Boot 설정
│   └── src/test/java/
│       └── com/realfds/dashboard/
│           ├── service/
│           │   ├── MetricsStoreTest.java
│           │   └── HealthCheckCollectorTest.java
│           └── websocket/
│               └── MetricsWebSocketHandlerTest.java
│
└── frontend/
    ├── src/
    │   ├── types/
    │   │   └── metrics.ts                    # TypeScript 타입 정의
    │   ├── hooks/
    │   │   └── useWebSocket.ts               # WebSocket 커스텀 훅
    │   ├── components/
    │   │   ├── dashboard/
    │   │   │   ├── DashboardLayout.tsx       # 대시보드 레이아웃
    │   │   │   ├── ServiceHealthCard.tsx     # 서비스 상태 카드
    │   │   │   ├── TpsChart.tsx              # TPS 라인 차트
    │   │   │   └── AlertRateChart.tsx        # 알림률 영역 차트
    │   │   └── common/
    │   │       └── ConnectionStatus.tsx      # 연결 상태 배너
    │   └── services/
    │       └── metricsApi.ts                 # REST API 클라이언트
    └── src/tests/
        ├── hooks/
        │   └── useWebSocket.test.ts
        └── components/
            └── dashboard/
                ├── ServiceHealthCard.test.tsx
                └── TpsChart.test.tsx
```

**Structure Decision**: Web application (backend + frontend) 구조를 선택했습니다. 이 기능은 기존 `alert-dashboard` 서비스에 통합되며, 백엔드는 Spring Boot 기반 메트릭 수집 및 WebSocket 서버, 프론트엔드는 React 기반 실시간 차트 대시보드입니다. 새로운 마이크로서비스를 추가하지 않으므로 Constitution IV를 준수합니다.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**결과**: 모든 Constitution 항목을 준수하며, 정당화가 필요한 위반 사항이 없습니다.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

## Phase 0: Research Artifacts

### Research Document

**File**: `specs/004-dashboard-realtime/research.md` (37 KB)

**Topics Researched**:

1. **Metrics Collection Strategy**
   - Decision: Spring Boot Actuator + Scheduled Polling (5-second intervals)
   - Rejected: Prometheus, Micrometer Push, RestTemplate

2. **Real-time Data Push Architecture**
   - Decision: Server-side Broadcast Pattern with WebSocket
   - Rejected: Per-client Subscription, SSE, Long Polling

3. **Time-Series Data Management**
   - Decision: ConcurrentLinkedDeque-based Circular Buffer
   - Rejected: LMAX Disruptor, Guava EvictingQueue, Time-series databases

4. **Frontend Charting Library**
   - Decision: Recharts (React-based)
   - Rejected: Chart.js, Victory, D3.js, Apache ECharts

5. **Service Health Monitoring**
   - Decision: Timeout-based DOWN detection (3 seconds) + Manual Retry
   - Rejected: Resilience4j Circuit Breaker, Netflix Hystrix, Spring Retry

**Key Findings**:
- Spring Boot Actuator의 `/actuator/health` 엔드포인트 표준 활용
- WebClient로 비동기 헬스 체크 수집 (3초 타임아웃)
- WebSocket broadcast로 모든 클라이언트에 동일한 메트릭 전송 (5명 이하 동시 접속 적합)
- ConcurrentLinkedDeque로 O(1) 삽입/삭제, 스레드 안전한 circular buffer
- Recharts로 부드러운 60fps 차트 애니메이션
- Exponential backoff 재연결 (1s → 32s)

## Phase 1: Design Artifacts

### Data Model

**File**: `specs/004-dashboard-realtime/data-model.md` (~25 KB)

**Core Entities**:

1. **ServiceHealth** (서비스 상태)
   - Fields: serviceName, status, lastChecked, responseTime, memoryUsage, errorType, errorMessage
   - Validation: 7 rules (서비스명 필수, 상태 enum, 타임스탬프 유효성 등)
   - Lifecycle: 5초마다 업데이트, 메모리 저장

2. **TransactionMetrics** (거래량 메트릭)
   - Fields: timestamp, tps, totalTransactions
   - Validation: 4 rules (TPS 0-10000, 단조 증가 등)
   - Storage: 720 data points (1시간)

3. **AlertMetrics** (알림 메트릭)
   - Fields: timestamp, alertsPerMinute, byRule (HIGH_VALUE, FOREIGN_COUNTRY, HIGH_FREQUENCY)
   - Validation: 6 rules (알림률 0-1000, 규칙별 합산 등)
   - Storage: 720 data points (1시간)

**WebSocket Message Formats**:
- METRICS_UPDATE: Server → Client (5초마다)
- BACKFILL_REQUEST: Client → Server (재연결 시)
- BACKFILL_RESPONSE: Server → Client (누락 데이터)
- ERROR: Server → Client (에러 알림)

**Backend Implementation**: Java 5개 클래스 (ServiceHealth, TransactionMetrics, AlertMetrics, MetricsDataPoint, MetricsStore)

**Frontend Implementation**: TypeScript 5개 인터페이스

**Memory Estimation**: <1MB (backend), <10MB (frontend)

### API Contracts

**Directory**: `specs/004-dashboard-realtime/contracts/` (80 KB total)

**Files**:

1. **rest-api.yaml** (16 KB)
   - OpenAPI 3.0 specification
   - Endpoints: GET /actuator/health, GET /api/v1/services, GET /api/v1/metrics/current
   - Full schemas with examples

2. **websocket-protocol.md** (26 KB)
   - Connection: ws://localhost:8083/ws/metrics
   - Message types: METRICS_UPDATE, BACKFILL_REQUEST, BACKFILL_RESPONSE, ERROR
   - Connection lifecycle, heartbeat, error handling
   - Performance characteristics, security considerations

3. **websocket-messages.json** (18 KB)
   - JSON Schema Draft 7
   - All message type schemas with validation rules
   - Enum constraints, min/max values, array size limits

4. **README.md** (20 KB)
   - Contracts overview and usage guide
   - Code generation instructions
   - Test case examples
   - Validation tools

**Key Design**:
- REST API for initial load (optional)
- WebSocket for real-time updates (mandatory)
- Ping-pong heartbeat every 30 seconds
- Exponential backoff reconnection
- No authentication (Constitution I)

### Quickstart Guide

**File**: `specs/004-dashboard-realtime/quickstart.md` (28 KB)

**Sections**:

1. **빠른 개요**: Feature summary, architecture diagram, estimated 3-4 days
2. **사전 요구사항**: Tools, 5 running services, knowledge prerequisites
3. **개발 환경 설정**: Dependencies, directory structure, configuration
4. **백엔드 구현 가이드**: 7 steps with production-ready code
   - MetricsStore, HealthCheckCollector, KafkaMetricsCollector, Scheduler, WebSocket handler
5. **프론트엔드 구현 가이드**: 5 steps with TypeScript code
   - useWebSocket hook, ServiceHealthCard, TpsChart, AlertRateChart, DashboardLayout
6. **테스트 가이드**: Unit tests, integration tests, manual scenarios
7. **기능 실행**: Start commands, access URL, demo scenarios
8. **검증 체크리스트**: All 26 FRs + 8 success criteria
9. **문제 해결**: 5 common issues with solutions
10. **다음 단계**: Performance optimization, future enhancements

**Implementation Highlights**:
- Complete code examples (not skeleton)
- All decisions from research applied
- Korean documentation throughout
- Constitution compliance notes

## Implementation Roadmap

### Phase 2: Task Generation (Next Step)

**Command**: `/speckit.tasks`

**Expected Output**: `specs/004-dashboard-realtime/tasks.md`

**Task Categories** (estimated):
1. **Backend - Data Models** (3 tasks)
   - T001: ServiceHealth, TransactionMetrics, AlertMetrics 엔티티 생성
   - T002: MetricsDataPoint 및 MetricsStore circular buffer 구현
   - T003: WebSocket 메시지 DTO 생성 (MetricsMessage)

2. **Backend - Metrics Collection** (5 tasks)
   - T004: HealthCheckCollector 구현 (Spring WebClient)
   - T005: KafkaMetricsCollector 구현 (Kafka AdminClient)
   - T006: MetricsScheduler 구현 (@Scheduled, 5초 주기)
   - T007: MetricsStore 통합 (circular buffer 데이터 저장)
   - T008: Spring Boot 설정 (application.yml, 환경 변수)

3. **Backend - WebSocket** (4 tasks)
   - T009: WebSocketConfig 설정 (Spring WebSocket)
   - T010: MetricsWebSocketHandler 구현 (broadcast)
   - T011: Backfill 요청 처리 로직
   - T012: 에러 처리 및 로깅

4. **Backend - REST API** (2 tasks)
   - T013: MetricsRestController 구현 (GET /api/v1/services, /metrics/current)
   - T014: Spring Actuator Health Check 엔드포인트 확인

5. **Frontend - Types & Hooks** (3 tasks)
   - T015: TypeScript 타입 정의 (metrics.ts)
   - T016: useWebSocket 커스텀 훅 구현 (reconnection, backfill)
   - T017: metricsApi REST 클라이언트 구현

6. **Frontend - Dashboard Components** (5 tasks)
   - T018: DashboardLayout 컴포넌트 (레이아웃)
   - T019: ServiceHealthCard 컴포넌트 (5개 서비스 상태)
   - T020: TpsChart 컴포넌트 (Recharts LineChart)
   - T021: AlertRateChart 컴포넌트 (Recharts AreaChart, stacked)
   - T022: ConnectionStatus 배너 컴포넌트 (연결 끊김 알림)

7. **Frontend - Integration** (2 tasks)
   - T023: Dashboard 페이지 통합 (모든 컴포넌트 조합)
   - T024: 라우팅 및 네비게이션 추가

8. **Testing** (6 tasks)
   - T025: MetricsStore 단위 테스트
   - T026: HealthCheckCollector 단위 테스트
   - T027: MetricsWebSocketHandler 통합 테스트
   - T028: useWebSocket 훅 테스트
   - T029: Dashboard 컴포넌트 통합 테스트
   - T030: 성능 테스트 (지연 시간, 메모리 사용량)

9. **Documentation & Deployment** (3 tasks)
   - T031: README 업데이트 (기능 설명, 실행 방법)
   - T032: Docker 이미지 빌드 및 docker-compose.yml 업데이트
   - T033: 최종 검증 (모든 FR 및 SC 확인)

**Total Tasks**: ~33 tasks

**Estimated Effort**: 3-4 days (22-30 hours) for experienced developer

### Phase 3: Implementation

**Command**: `/speckit.implement`

**Process**:
1. Read `tasks.md`
2. Execute tasks sequentially
3. Run tests after each task group
4. Update TODO list
5. Commit with Conventional Commits (Korean)

### Phase 4: Verification

**Checklist** (from quickstart.md):

**Functional Requirements** (26개):
- [ ] FR-001: 5개 서비스 Health Check 수집
- [ ] FR-002: 상태 UP/DOWN 분류
- [ ] FR-003: 5초마다 자동 업데이트
- [ ] FR-004: 중단 감지 후 3초 이내 반영
- [ ] FR-005: 서비스 상태 카드 표시
- [ ] FR-006: 서비스 상세 정보 모달
- [ ] FR-007: TPS 실시간 수집
- [ ] FR-008: 1시간 데이터 유지
- [ ] FR-009: 거래량 선 그래프 표시
- [ ] FR-010: 5초마다 차트 업데이트
- [ ] FR-011: 현재/평균/최대 TPS 표시
- [ ] FR-012: 차트 마우스 호버 툴팁
- [ ] FR-013: 분당 알림 수 수집
- [ ] FR-014: 1시간 데이터 유지
- [ ] FR-015: 알림 영역 차트 표시
- [ ] FR-016: 3가지 규칙 유형 분류
- [ ] FR-017: 규칙별 스택 차트
- [ ] FR-018: 범례 클릭 필터링
- [ ] FR-019: 현재/평균/최대 알림률 표시
- [ ] FR-020: 알림률 2배 초과 시 주황색
- [ ] FR-021: 차트 부드러운 전환
- [ ] FR-022: 초기 로딩 <2초
- [ ] FR-023: 수치 업데이트 애니메이션
- [ ] FR-024: 연결 끊김 배너 및 재연결
- [ ] FR-025: "데이터 수집 중..." 메시지
- [ ] FR-026: Y축 자동 범위 조정

**Success Criteria** (8개):
- [ ] SC-001: 메트릭 업데이트 평균 4초, 최대 5초
- [ ] SC-002: 차트 부드러운 애니메이션
- [ ] SC-003: 서비스 DOWN 평균 2초, 최대 3초
- [ ] SC-004: 대시보드 로딩 <2초
- [ ] SC-005: 1시간 사용 중 성능 유지
- [ ] SC-006: 5명 동시 접속 정상 작동
- [ ] SC-007: 장애 발견 및 상세 정보 확인 <10초
- [ ] SC-008: 차트 수치 확인 <2초

## Performance Benchmarks

**Expected Metrics** (from research and data model):

| Metric | Target | Measured | Status |
|--------|--------|----------|--------|
| Health Check Collection Time | <3s | TBD | Pending |
| Kafka Metrics Collection Time | <1s | TBD | Pending |
| WebSocket Broadcast Latency | <100ms | TBD | Pending |
| Chart Rendering Time | <50ms | TBD | Pending |
| End-to-End Update Latency | <5s | TBD | Pending |
| Memory Usage (Backend) | <1MB | TBD | Pending |
| Memory Usage (Frontend) | <10MB | TBD | Pending |
| Concurrent Users | 5 | TBD | Pending |
| Uptime (1 hour) | 100% | TBD | Pending |

## Risks & Mitigations

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| WebSocket 연결 불안정 | High | Medium | Exponential backoff 재연결, Ping-pong heartbeat |
| 차트 렌더링 성능 저하 | Medium | Low | Recharts 최적화, 데이터 포인트 제한 (720개) |
| 메모리 누수 | High | Low | Circular buffer 자동 삭제, 1시간 제한 |
| Health Check 타임아웃 | Medium | Medium | 3초 타임아웃, 에러 처리 로깅 |
| Kafka AdminClient 오버헤드 | Low | Low | 경량 API 사용, 메타데이터만 조회 |
| 동시 접속자 증가 | Medium | Low | 최대 5명 제한, 브로드캐스트 패턴 |

## Dependencies & Blockers

**Prerequisite Features**:
- [x] 001-realtime-fds: 5개 마이크로서비스 인프라 (완료)
- [x] 002-alert-management: Alert 규칙 관리 (완료)
- [x] 003-alert-history: Alert 이력 조회 (완료, 별도 기능)

**External Dependencies**:
- None (모든 기능 내부 시스템 사용)

**Blockers**:
- None (모든 전제 조건 충족)

## Rollout Plan

### Development Phase

1. **Week 1**:
   - Backend: Data models, MetricsStore, HealthCheckCollector
   - Frontend: TypeScript types, useWebSocket hook
   - Testing: Unit tests

2. **Week 2**:
   - Backend: KafkaMetricsCollector, Scheduler, WebSocket handler
   - Frontend: Dashboard components, charts
   - Testing: Integration tests

3. **Week 3**:
   - Integration: Backend + Frontend 통합
   - Performance testing
   - Bug fixes

4. **Week 4**:
   - Documentation: README, quickstart verification
   - Final verification checklist
   - Demo preparation

### Deployment

1. **Build**: `./gradlew clean build` (backend), `npm run build` (frontend)
2. **Docker**: `docker build -t realfds/alert-dashboard:1.2.0 .`
3. **Compose**: `docker-compose up -d`
4. **Verify**: Access http://localhost:8083/dashboard
5. **Monitor**: Check all 5 services showing UP status

## Post-Implementation

### Monitoring

- **Metrics to Track**:
  - WebSocket 연결 수
  - 메트릭 업데이트 지연 시간
  - 차트 렌더링 시간
  - 메모리 사용량
  - 에러 발생 빈도

- **Logging**:
  - INFO: 메트릭 수집 시작/완료, WebSocket 연결/해제
  - WARN: Health Check 타임아웃, 재연결 시도
  - ERROR: Kafka 연결 실패, WebSocket 브로드캐스트 실패

### Future Enhancements

**Out of Scope for this feature** (defer to future versions):
- 메트릭 데이터 영구 저장 (PostgreSQL)
- 1시간 이상 과거 메트릭 조회
- 알림 임계값 설정 UI
- 메트릭 데이터 내보내기 (CSV/JSON)
- 사용자별 대시보드 커스터마이징
- 사용자 인증 및 권한 관리

## References

- **Feature Spec**: [spec.md](./spec.md)
- **Research**: [research.md](./research.md) (37 KB)
- **Data Model**: [data-model.md](./data-model.md) (~25 KB)
- **API Contracts**: [contracts/](./contracts/) (80 KB)
- **Quickstart**: [quickstart.md](./quickstart.md) (28 KB)
- **Constitution**: [.specify/memory/constitution.md](../../.specify/memory/constitution.md)

---

**Plan Status**: ✅ Complete
**Version**: 1.0.0 | **Created**: 2025-11-12 | **Last Updated**: 2025-11-12
**Author**: SpecKit Plan Command
**Next Step**: `/speckit.tasks` to generate implementation tasks
